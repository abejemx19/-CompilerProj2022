# -CompilerProj2022

# Fortran Compiler in C++

This project is a Fortran compiler built using C++. The compiler was developed through several steps and topics covered in our readings, labs, and assignments.

## Introduction

In the first week of the project, we introduced the course and discussed the different paradigms, criteria, and types of translators. 
We also covered the basics of hardware, firmware, and virtual machines. We completed problem sets that included questions on these topics. 
These problem sets were discussed in class to ensure that everyone had a solid understanding of the material.

## Syntax and Translation Stages

In the following weeks, we delved deeper into syntax and translation stages. 
We discussed compiler overview and the evolution of major programming languages. We also covered formal languages such as finite-state machines 
(FSMs) and Backus-Naur Form (BNF). We worked on compiler projects that included lexical analysis, parsing, and grammar load.

During this stage of development we focused on understanding the different stages of translation and how they fit together. 
We also learned about the tools and techniques used in each stage.

## Unix and C++

We reviewed Unix and C++ during this time. We practiced compiling code using makefiles. We also explored the basics of Pascal and worked on exercises 
related to stack machine architecture.

During this stage of development, we focused on understanding how to use Unix and C++ to develop our compiler.
We also learned about makefiles and how they can be used to automate the compilation process.

## Lexical and Syntactic Analysis

We covered lexical and syntactic analysis during this stage of development. This included context-free grammars and bottom-up parsing. 
We also discussed yacc and bison.

During this stage of development, we focused on understanding how lexical analysis works and how it fits into the overall translation process. 
We also learned about context-free grammars and how they can be used to represent the syntax of a programming language. We also learned about bottom-up parsing and how it can be used to analyze the syntax of a program.

## Names and Binding

We then moved on to names and binding. We discussed symbol table management, scoping, lifetime, and environments. 
We explored primitive and structured data types such as arrays and structures. We completed problem sets that included questions on these topics.

During this stage of development, we focused on understanding how names are bound to values in a program. We also learned about symbol table management and 
how it can be used to keep track of names and their associated values.

## Testing

To test our compiler, we made use of a few programs to see how it was functioning. We made changes as necessary based on the results of our tests.

During this stage of development, we focused on ensuring that our compiler was functioning correctly. We ran tests using various programs to see if our
compiler was producing the expected output.

## Handling Different Scenarios

During development, we had to consider the lexical analyzer and watch out for different scenarios. For example we had to deal with cases where the same 
symbol was used differently based on different contexts. We handled these scenarios by implementing appropriate logic in our code.

During this stage of development, we focused on understanding how to handle different scenarios that can arise during lexical analysis. 
We implemented logic in our code to handle cases where the same symbol was used differently based on context.

## Conclusion

In conclusion, this project demonstrates how to build a Fortran compiler using C++. The process involved several steps and topics covered in our readings,
labs, and assignments. Through testing and careful consideration of different scenarios, we were able to develop a functional compiler.
